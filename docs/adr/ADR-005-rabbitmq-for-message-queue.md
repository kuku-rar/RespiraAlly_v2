# ADR-005: 採用 RabbitMQ 作為異步任務的訊息佇列

**狀態**: 已決定 (Accepted)

**日期**: 2025-10-13

## 背景 (Context)

RespiraAlly V2 系統中包含多個需要異步處理的耗時任務，最典型的就是 AI 語音處理鏈 (STT -> LLM -> TTS)。如果同步處理這些請求，將會導致 API 長時間阻塞，嚴重影響使用者體驗。因此，引入一個訊息佇列 (Message Queue) 來解耦服務和實現異步處理是必要的架構決策。

## 決策驅動力 (Decision Drivers)

*   **解耦服務**: 主 API 服務不應被耗時的背景任務（如 AI 推理）拖累。
*   **削峰填谷**: 在高併發請求下，將任務放入佇列，由 Worker 按照自身處理能力消費，保護後端系統不被衝垮。
*   **可靠性與重試**: 確保任務（如發送重要通知）即使在短暫失敗後也能被重試，最終成功執行。
*   **可擴展性**: 可以獨立地擴展生產者（API 服務）和消費者（Worker 服務）的數量。

## 考量的方案 (Considered Options)

### 方案 1: 使用 Celery + Redis/RabbitMQ

*   **優點**:
    *   Celery 是 Python 生態中非常成熟的分散式任務佇列框架，功能豐富。
    *   與 Python/FastAPI 整合度高，有大量的教學和社群支持。
    *   內建了重試、排程、監控等進階功能。
*   **缺點**:
    *   **框架過重**: Celery 本身是一個較重的框架，對於我們目前相對簡單的任務場景，可能引入了不必要的複雜性。
    *   **配置複雜**: Celery 的配置選項繁多，有時會讓開發者感到困惑。

### 方案 2: 使用 Kafka

*   **優點**:
    *   **極高吞吐量**: 為處理大規模事件流而設計，性能非常出色。
    *   **持久化日誌**: Kafka 的主題 (Topic) 是持久化的，允許多個消費者以不同速度消費，並能重播 (replay) 事件，非常適合事件溯源 (Event Sourcing) 架構。
*   **缺點**:
    *   **運維複雜**: 運維一個 Kafka 叢集（包括 Zookeeper）比 RabbitMQ 複雜得多。
    *   **不適合 RPC**: Kafka 的設計模式不適合請求/回應 (RPC) 風格的任務。
    *   **功能過剩**: 對於我們目前的「任務分發」場景，Kafka 的事件流特性有些大材小用。

### 方案 3: 直接使用 RabbitMQ (最終選擇)

*   **優點**:
    *   **成熟穩定**: 是業界應用最廣泛、最成熟的訊息佇列之一。
    *   **協議標準**: 基於 AMQP 標準協議，客戶端支援廣泛。
    *   **靈活的路由**: 提供多種交換機類型 (Direct, Fanout, Topic, Headers)，可以實現非常靈活的訊息路由策略，不僅能做任務佇列，也能做發布/訂閱。
    *   **功能完善**: 內建了訊息確認 (Acknowledgement)、持久化、TTL、死信佇列 (Dead-lettering) 等企業級特性，足以滿足我們的可靠性需求。
    *   **輕量與平衡**: 相較於 Kafka，它更輕量，更專注於訊息傳遞，非常適合我們的任務佇列場景。
*   **缺點**:
    *   **吞吐量極限**: 雖然性能很好，但在極端高吞吐量（每秒數十萬以上）的場景下不如 Kafka。
    *   **無內建日誌重播**: 不像 Kafka 那樣適合做事件溯源的底層儲存。

## 決策 (Decision)

我們決定選擇 **方案 3: 直接使用 RabbitMQ** 作為訊息中介。

我們不選擇 Celery 是因為希望保持架構的輕量，直接使用一個訊息佇列客戶端 (如 Pika) 加上我們自訂的 Worker 邏輯，能讓我們更好地控制程式碼，避免被重型框架綁定。

在 RabbitMQ 和 Kafka 之間，我們選擇了 RabbitMQ，因為它更符合我們當前的需求——一個可靠、靈活的「任務路由器」。Kafka 更像是一個「分散式事件日誌」，雖然強大，但運維複雜且與我們的使用場景不完全匹配。RabbitMQ 在功能、成熟度和運維複雜度之間取得了最佳的平衡。

## 後果 (Consequences)

*   **正面**:
    *   API 服務與 AI Worker 服務成功解耦，提高了系統的響應速度和穩定性。
    *   我們可以利用 RabbitMQ 的特性輕鬆實現任務的可靠投遞和失敗重試。
    *   架構保持了靈活性，未來可以利用 Topic 交換機來實現更複雜的發布/訂閱模式。
*   **負面**:
    *   **運維成本**: 引入了 RabbitMQ 這個新元件，需要對其進行監控和管理。在 MVP 階段，我們會使用 Zeabur 的託管服務來降低此成本。
    *   **單點故障風險**: 在 MVP 階段，我們將部署單節點的 RabbitMQ，這會是一個潛在的單點故障。在產品成熟後，需要規劃遷移到高可用的 RabbitMQ 叢集。
